Given two months (possibly different years).
Naive algorithm traverses the second month for all samples in the first.
=> O(k^2), where k is at most ~ 9000

Another approach might be to perform a pre-computation and group the data samples.

Begin with naive algorithm and implements all the other logic.
Hopefully the db-cost won't be too significant.
Minutes of processing time is reasonable.

Given two series s1, s2 and some epsilon.
Check if all samples (of voltage, current, and temperature) but k are within epsilon.

The result is a list of (addr, measurement, difference) of all points that differ significantly.

Given two vectors v1 and v2.
v' = abs(v1 - v2)
filtered = filter (>= epsilon) v'
if (length filtered <= k) $ emit address, type, and time of entries in filtered

Use some empirically determined epsilon.

-- note that we should only emit large differences in voltage and current

Implement this function generically since it might be of interest to add averaged windows later.
(Due to noise we might otherwise have false-positives)
-- note that we should only emit large differences in voltage and current

This can be tested by supporting "degradation fault" injection which applies a time-dependent function on the original data series.
=> Inject a degradation and determine the precision in classification performance.
   (Rate of false-positives and least required fault that can be detected).
   Doesn't need to be exhaustive.

====================================
========== IMPLEMENTATION ==========
====================================

Use the retrieve-day function to pull all three vectors for a specific day.
Apply the check-functions on two vectors and aggregate the results.

The check functions basically performs the operations outlined above per module.
Given:   [(uvec, ivec, tvec)] (each entry for two dfferent days), all modules
Eval:    proc(uvec,uvec'), proc(ivec,ivec'), proc(tvec,tvec') over all entries (i.e. all modules)
Check:   Step through the daily time frame. Apply (< epsilon) on all.
Reduce:  If all three are true then 1 else 0
Signal:  for each time slot, if sum (...) == n - k then signal valid indicator at this time position
Extract: extract the amount of degradation at the specified time points (clamped)

Use existing fault injection data, but also add extra noise to irradiance and temperature.

process:
  for every module-series s in days // fix one point in time
    for every modules-series s' in days after (day of s)
      [vec] <- for every module
        this processed as a (1) map over each cell, reducing it into 1/0

      (2) fold across columns (in [vec]), aggregating all the time slots, taking the sum
      (3) map over the vector with (>= n - k)

      the resulting vector has indicators for every time slot which can be processed by other operations.

what is the result of the routine outlined above? type signature?

-- returns (voltage, current) tuples indicating the degradation
-- these can be internally averaged for several samples.
-- begin with a primtive single-sample-version
measureTimePeriod :: Day -> Day -> IO (Maybe [(Double, Double)])
measureTimePeriod firstWindow secondWindow = do
  [first, second] <- mapM fetchMonth [firstWindow, secondWindow]
  let maxSamples = undefined
  res <- fmap concat . forM [0..maxSamples-1] $ \idx -> do
    indicators <- forM [idx..maxSamples-1] $ \idx' -> do
      let grabVec f vec step = V.map (U.map (\entry -> f entry ! step)) vec
          vecDiffs f         = V.map (\(x,y) -> abs $ x - y) $ V.zip (grabVec f first idx) (grabVec f second idx')
          classify           = V.map (<= epsilon) . vecDiffs
          (vec1, vec2, vec3) = (classify (\(x,_,_) -> x), classify (\(_,y,_) -> y), classify (\(_,_,z) -> z))
          moduleSum          = sum $ map (\m -> if (vec1 ! m) + (vec2 ! m) + (vec3 ! m) == 3 then 1 else 0) [0..modules-1]

      if moduleSum >= modules - allowedFailures then
        return [(idx', V.toList $ vecDiffs (\(x_,_,_) -> x), V.toList $ vecDiffs (\(_,y,_) -> y)]
        else return []

    return . map (\pair -> (idx, pair)) $ concat indicators 

  where
  system = 1
  modules = 24
  allowedFailures = 1
  epsilon = 1e-2
  fetchMonth day = do
    first <- mapM (retrieveDay system modules) $ take 30 [day ...]
    -- first :: [V.Vector (Vec, Vec, Vec)]
    -- wan't something like V.Vector (Vec, Vec, Vec) only
